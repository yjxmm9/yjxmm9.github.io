# C#

C#执行原理底层：[深度理解C# 的执行原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/47177008)





## 内存相关

------





### C#中的GC

- C# 中使用的是分代回收算法，它是一种结合了复制算法、标记-清除算法和标记-整理算法的算法。该算法将内存划分为三代：0 代、1 代和 2 代。新创建的对象会被分配到 0 代，如果在第一次垃圾回收时存活下来，它们会被移动到 1 代。如果在第二次垃圾回收时存活下来，它们会被移动到 2 代。
- 垃圾回收器会定期检查各代中的对象并标记已死亡的对象，然后进行垃圾回收。对于 0 代和 1 代的对象，通常使用复制算法，而对于 2 代的对象，则使用标记-整理算法。这种算法可以高效地回收短期存活的对象，同时也能够有效地处理长期存活的对象，而且不会产生太多的内存碎片。

[C# 垃圾回收机制 - 简书 (jianshu.com)](https://www.jianshu.com/p/cc57aa7f3824)





### GC中根结点在哪里

1. 在CPU寄存器中被引用的对象
2. 在线程堆栈中的被引用的对象
3. 静态对象
4. 运行时保存的任何内部对象引用







### 托管资源和非托管资源（Finalizer和Dispose）

**托管资源**指的是.NET可以**自动进行回收**的资源，主要是指**托管堆**上分配的内存资源。托管资源的回收工作是不需要人工干预的，由.NET运行库在合适时机**调用垃圾回收器**进行回收。

**非托管资源**指的是.NET**不知道如何回收**的资源，最常见的一类非托管资源是包装操作系统资源的对象，例如：文件、窗口、网络连接、数据库连接、画刷、图标等。这类资源需要手动实现**Finalizer()或Dispose()方法释放非托管资源**。

1、Finalize方法（C#中是**析构函数**，以下称析构函数）是**用于释放非托管资源**的，而托管资源会由GC自动回收。所以，我们也可以这样来区分 托管和非托管资源。所有会由GC自动回收的资源，就是托管的资源，而不能由GC自动回收的资源，就是非托管资源。在我们的类中直接使用非托管资源的情况很 少，所以基本上不用我们写析构函数。

2、大部分的非托管资源会给系统带来很多负面影响，例如数据库连接不被释放就可能导致连接池中的可用数据库连接用尽。文件不关闭会导致其它进程无法读写这个文件等等。

实现模型：
1、由于大多数的非托管资源都要求可以手动释放，所以，我们应该专门为释放非托管资源公开一个方法。实现IDispose接口的Dispose方法是最好的模型，因为C#支持using语句快，可以在离开语句块时自动调用Dispose方法。

2、虽然可以手动释放非托管资源，我们仍然要在析构函数中释放非托管资源，这样才是安全的应用程序。否则如果因为程序员的疏忽忘记了手动释放非托管资源， 那么就会带来灾难性的后果。所以说在析构函数中释放非托管资源，是一种补救的措施，至少对于大多数类来说是如此。

3、由于**析构函数的调用将导致GC对对象回收的效率降低**，所以如果已经完成了析构函数该干的事情（例如释放非托管资源），就应当使用SuppressFinalize方法告诉GC不需要再执行某个对象的析构函数。

4、**析构函数中只能释放非托管资源而不能对任何托管的对象/资源进行操作**。因为你无法预测析构函数的运行时机，所以，当析构函数被执行的时候，也许你进行操作的托管资源已经被释放了。这样将导致严重的后果。

5、（这是一个规则）如果一个类拥有一个实现了IDispose接口类型的成员，并创建（注意是创建，而不是接收，必须是由类自己创建）它的实例对象，则 这个类也应该实现IDispose接口，并在Dispose方法中调用所有实现了IDispose接口的成员的Dispose方法。
只有这样的才能保证所有实现了IDispose接口的类的对象的Dispose方法能够被调用到，确保可以手动释放任何需要释放的资源。











### 拆箱和装箱

[.NET面试题解析(02)-拆箱与装箱 - 不灬赖 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ljdong7/p/12021271.html)

#### 1.什么是拆箱和装箱？

装箱就是值类型转换为引用类型，拆箱就是引用类型（被装箱的对象）转换为值类型。

#### 2.什么是箱子？

就是引用类型对象。

#### 3.箱子放在哪里？

托管堆上。

#### 4.装箱和拆箱有什么性能影响？

装箱和拆箱都涉及到内存的分配和对象的创建，有较大的性能影响。

#### 5.如何避免隐身装箱？

多使用泛型、显示装箱。

#### 6.箱子的基本结构？

上面说了，箱子就是一个引用类型对象，因此她的结构，主要包含两部分：

- 值类型字段值；
- 引用类型的标准配置，引用对象的额外空间：TypeHandle和同步索引块

#### 7.装箱的过程？

​	1.在堆中申请内存，内存大小为值类型的大小，再加上额外固定空间（引用类型的标配：TypeHandle和同步索引块）；
​	2.将值类型的字段值（x=1023）拷贝新分配的内存中；
​	3.返回新引用对象的地址（给引用变量object o）

#### 8.拆箱的过程？

​	1.检查实例对象（object o）是否有效，如是否为null，其装箱的类型与拆箱的类型（int）是否一致，如检测不合法，抛出异常；
​	2.指针返回，就是获取装箱对象（object o）中值类型字段值的地址；
​	3.字段拷贝，把装箱对象（object o）中值类型字段值拷贝到栈上，意思就是创建一个新的值类型变量来存储拆箱后的值；





### 值类型和引用类型



值类型：整数、浮点、bool、char、**struct**、**enum**

引用类型：string，object，**class**，interface，delegate，**array**（除了值类型以外的所有类型）



#### 1. 值类型和引用类型的区别？

值类型包括简单类型、结构体类型和枚举类型，引用类型包括自定义类、数组、接口、委托等。

​	1、赋值方式：将一个值类型变量赋给另一个值类型变量时，将复制包含的值。这与引用类型变量的赋值不同，引用类型变量的赋值只复制对象的引用（即内存	地址，类似C++中的指针），而不复制对象本身。

​	2、继承：**值类型不可能派生出新的类型**，所有的值类型均隐式派生自 System.ValueType。但与引用类型相同的是，**结构也可以实现接口**。

​	3、null：与引用类型不同，值类型不可能包含 null 值。然而，可空类型允许将 null 赋给值类型（他其实只是一种语法形式，在clr底层做了特殊处理）。

​	4、每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值，值类型初始会默认为0，引用类型默认为null。

​	5、**值类型存储在栈中，引用类型存储在托管堆中**。



#### 2. 结构和类的区别？

- 值类型存储在栈中，引用类型存储在托管堆中
- 赋值方式：将一个值类型变量赋给另一个值类型变量时，将复制包含的值。这与引用类型变量的赋值不同，引用类型变量的赋值只复制对象的引用（即内存	地址，类似C++中的指针），而不复制对象本身
- 继承：**值类型不可能派生出新的类型**
- **结构不支持无惨构造函数**，不支持析构函数，并且不能有protected修饰；
- 结构常用于数据存储，类class多用于行为；
- class需要用new关键字实例化对象，struct可用可不用new关键字；
- class可以为抽象类，struct不支持抽象；







#### struct为什么不能继承？

从语法上来说，**struct继承`ValueType`的时候是隐式密封的**，观察相应的IL代码即可发现`sealed`关键字。 从设计上来说，struct多用于纯数据的集合（也可以有逻辑），内存布局比较简单，没有类型对象指针和同步块索引。因此不能直接支持多态。







#### 3. delegate是引用类型还是值类型？enum、int[]和string呢？

enum枚举是值类型，其他都是引用类型。



#### 4. 堆和栈的区别？

```
线程堆栈：简称栈 Stack
托管堆： 简称堆 Heap
```

- 值类型大多分配在栈上，引用类型都分配在堆上；
- **栈由操作系统管理**，栈上的变量在其作用域完成后就被释放，效率较高，但空间有限。**堆受CLR的GC控制**；
- **栈是基于线程的**，每个线程都有自己的线程栈，初始大小为1M。**堆是基于进程的**，一个进程分配一个堆，堆的大小由GC根据运行情况动态控制；



#### 6.“结构”对象可能分配在堆上吗？什么情况下会发生，有什么需要注意的吗？

结构是值类型，有两种情况会分配在对上面：

- 结构作为class的一个字段或属性，会随class一起分配在堆上面；
- 装箱后会在堆中存储，尽量避免值类型的装箱，值类型的拆箱和装箱都有性能损失



#### 7. 理解参数按值传递？以及按引用传递？

- 按值传递：对于值类型传递的它的值拷贝副本，而引用类型传递的是引用变量的内存地址，他们还是指向的同一个对象（又创建了新的引用指向同一个对象）。
- 按引用传递：通过关键字out和ref传递参数的内存地址，值类型和引用类型的效果是相同的（直接将原来的对象作为参数，不会创建新的引用）。



#### 8. `out` 和 `ref`的区别与相同点？

- `out` 和 `ref`都**指示编译器传递参数地址**，在行为上是相同的；
- 他们的使用机制稍有不同，ref要求参数在使用之前要显式初始化，out要在方法内部初始化；
- `out` 和 `ref`**不可以重载**，就是不能定义Method(ref int a)和Method(out int a)这样的重载，从编译角度看，二者的实质是相同的，只是使用时有区别；



#### 9. C#支持哪几个预定义的值类型？C#支持哪些预定义的引用类型？

值类型：整数、浮点数、字符、bool和decimal

引用类型：Object，String



#### 10. 有几种方法可以判定值类型和引用类型？

简单来说，继承自System.ValueType的是值类型，反之是引用类型。



#### 11. 说说值类型和引用类型的生命周期？

值类型在作用域结束后释放。

引用类型由GC垃圾回收期回收。具体见C#中的GC部分



#### 12. 如果结构体中定义引用类型，对象在内存中是如何存储的？例如下面结构体中的class类 User对象是存储在栈上，还是堆上？

```
public struct MyStruct 
{ 
    public int Index; 
    public User User; 
}
```

MyStruct存储在栈中，其字段User的实例存储在堆中，MyStruct.User字段存储指向User对象的内存地址。







## C++











## 面向对象



### 面向对象三大特点

- 封装
  - 将**数据**和**行为**封装在一个对象内部
  - 通过对象的接口暴露部分行为给外部使用，限制外部对数据的直接访问和修改，同时隐藏了对象的具体实现细节
  - 使得代码更加模块化、易于维护和修改，同时也可以保护数据的安全性
- 继承
  - 提高代码重用度，增强软件可维护性，符合开闭原则（对于扩展是开放的，但是对于修改是封闭）。
  - 层次结构：形成一个层次结构，使代码更加清晰、易于组织和管理
  - 多态：继承也是实现多态性的重要手段。通过继承，子类可以重写或覆盖父类的方法，并且在程序运行时，根据实际对象类型调用相应的方法，实现不同的行为
  - 继承的传递性：传递机制 a▶b; b▶c; c具有a的特性 。
  - 继承的单根性：在C#中一个类只能继承一个类，不能有多个父类。
- 多态
  - 多态是同一个行为具有多个不同表现形式或形态的能力。
  - 多态性可以是静态的或动态的。在**静态多态性**中，函数的响应是在编译时发生的。在**动态多态性**中，函数的响应是在运行时发生的
    - 静态多态（早绑定）：函数重载，运算符重载
      - **方法签名**：方法名称，参数类型、参数名称、参数顺序、参数的参数修饰符
      - 当我们定义一个方法时，编译器会根据方法的名称和参数列表生成一个独一无二的方法签名，并将其保存到元数据中。
      - 具体来说，编译器会将方法调用的信息编译成一条IL指令，指令中包含了方法名称和参数信息。当程序运行时，CLR会解释这条指令，根据方法名称和参数信息来查找匹配的方法签名，并根据签名来执行对应的方法体。
    - 动态多态（晚绑定）：派生类（`abstract`），虚函数（`virtual`）
      - 动态多态的底层原理：
        - [C#中的多态性 - zhangkai2237 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhangkai2237/archive/2012/12/20/2826734.html)
        - [.NET面试题解析(04)-类型、方法与继承 - 不灬赖 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ljdong7/p/12021305.html)



### 私有构造函数

私有构造函数是一种特殊的实例构造函数。它**通常用在只包含静态成员的类**中。如果类具有一个或多个私有构造函数而没有公共构造函数，则其他类（除嵌套类外）无法创建该类的实例。





### 重载和重写的区别

从定义一个函数的角度去记忆：位置->访问修饰符->返回值->参数->作用

1. 参数列表不同：重载是通过方法的参数列表来区分不同的方法，而重写是通过方法的实现来区分不同的方法。
2. 位置不同：重载是在同一个类中定义的多个方法，而重写是在子类中重写或覆盖父类的方法。
3. 返回值不同：重载允许方法返回不同的类型，而重写要求方法返回值类型必须与父类方法的返回值类型相同，或者是其子类。
4. 访问修饰符不同：重载可以定义在同一个类中的不同访问修饰符下的方法，而重写要求方法的访问修饰符不能低于父类方法的访问修饰符。
5. 功能不同：重载的方法可以实现不同的功能，而重写的方法必须实现与父类相同的功能。





### private，public，protected，internal的区别

- public：对任何类和成员都公开，无限制访问
- private：仅对该类公开
- protected：对该类和其派生类公开
- internal：只能在包含该类的程序集中访问该类
- protected internal：protected + internal



以下题目具体原理参考：[.NET面试题解析(04)-类型、方法与继承 - 不灬赖 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ljdong7/p/12021305.html)

### 所有类型都继承System.Object吗？

基本上是的，所有值类型和引用类型都继承自System.Object，接口是一个特殊的类型，不继承自System.Object。





###  解释virtual、sealed、override和abstract的区别

- virtual申明虚方法的关键字，说明该方法可以被重写
- sealed说明该类不可被继承
- override重写基类的方法
- abstract申明抽象类和抽象方法的关键字，抽象方法不提供实现，由子类实现，抽象类不可实例化。





### 什么是接口

接口简单理解就是一种规范、契约，使得实现接口的类或结构在形式上保持一致。实现接口的类或结构必须实现接口定义中所有接口成员，以及该接口从其他接口中继承的所有接口成员。**可以把接口看做是一种特殊的抽象类**，该类只提供定义，没有实现。

基本特点：

- 接口使用interface声明；
- 接口类似于抽象基类，不能直接实例化接口；
- 接口中的方法都是抽象方法，不能有实现代码，实现接口的任何非抽象类型都**必须实现接口的所有成员**：
- 接口成员是自动公开的，且**不能包含任何访问修饰符**。
- 接口自身可从多个接口继承，类和结构可继承多个接口，但接口不能继承类。
- 接口只包含方法、属性、索引器、事件





### 接口和类有什么异同？

**不同点：**

1、接口不能直接实例化。

2、接口只包含方法或属性的**声明**，不包含方法的实现。

3、接口可以**多继承**，类只能单继承。

4、表达的含义不同，接口主要定义一种**规范**，统一调用方法，也就是规范类，约束类，类是方法功能的实现和集合

**相同点：**

1、接口、类和结构都可以从多个接口继承。

2、接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。

3、接口和类都可以包含事件、索引器、方法和属性。







### 抽象类和接口有什么区别？

1、继承：接口支持多继承；抽象类不能实现多继承。

2、表达的概念：接口用于规范，更强调契约，抽象类用于共性，强调父子。抽象类是一类事物的高度聚合，那么对于继承抽象类的子类来说，对于抽象类来说，属于"Is A"的关系；而接口是定义行为规范，强调“Can Do”的关系，因此对于实现接口的子类来说，相对于接口来说，是"行为需要按照接口来完成"。

3、方法实现：对抽象类中的方法，即**可以给出实现部分，也可以不给出**；而接口的方法（抽象规则）都**不能给出实现部分**，接口中方法不能加修饰符。

4、子类重写：继承类对于两者所涉及方法的实现是不同的。继承类对于抽象类所定义的抽象方法，**可以不用重写**，也就是说，可以延用抽象类的方法；而对于接口类所定义的方法或者属性来说，在继承类中**必须重写**，给出相应的方法和属性实现。

5、接口可以作用于**值类型（枚举可以实现接口）和引用类型**；抽象类只能作用于**引用类型**。

6、接口不能包含字段和已实现的方法，接口只包含方法、属性、索引器、事件的签名；抽象类可以定义字段、属性、包含有实现的方法。







### 在继承中new和override相同点和区别？看下面的代码，有一个基类A，B1和B2都继承自A，并且使用不同的方式改变了父类方法Print（）的行为。测试代码输出什么？为什么？

```c#
public void DoTest()
{
    B1 b1 = new B1(); B2 b2 = new B2();
    b1.Print(); b2.Print();      //按预期应该输出 B1、B2

    A ab1 = new B1(); A ab2 = new B2();
    ab1.Print(); ab2.Print();   //这里应该输出什么呢？输出B1、A
}
public class A
{
    public virtual void Print() { Console.WriteLine("A"); }
}
public class B1 : A
{
    public override void Print() { Console.WriteLine("B1"); }
}
public class B2 : A
{
    public new void Print() { Console.WriteLine("B2"); }
}
```

去了解C#中动态多态的底层原理



### 下面代码中，变量a、b都是int类型，代码输出结果是什么？

```C#
int a = 123;
int b = 20;
var atype = a.GetType();
var btype = b.GetType();
Console.WriteLine(System.Object.Equals(atype,btype));          //输出True
Console.WriteLine(System.Object.ReferenceEquals(atype,btype)); //输出True
```





### class中定义的静态字段是存储在内存中的哪个地方？为什么会说她不会被GC回收？

随类型对象存储在内存的加载堆上，因为加载堆不受GC管理，其生命周期随AppDomain，不会被GC回收。



以下问题参考：[.NET面试题解析(05)-常量、字段、属性、特性与委托 - 不灬赖 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ljdong7/p/12021317.html)



### const和readonly有什么区别？

const关键字用来声明编译时常量，readonly用来声明运行时常量。都可以标识一个常量，主要有以下区别：
1、初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以在构造方法里赋值。
2、修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段 。
3、const是编译时常量，在编译时确定该值，且值在编译时被内联到代码中；readonly是运行时常量，在运行时确定该值。
4、const默认是静态的；而readonly如果设置成静态需要显示声明 。
5、支持的类型时不同，const只能修饰基元类型或值为null的其他引用类型；readonly可以是任何类型。





### 哪些类型可以定义为常量？常量const有什么风险？

基元类型或值为null的其他引用类型，常量的风险就是不支持跨程序集版本更新，常量值更新后，所有使用该常量的代码都必须重新编译。





### 字段与属性有什么异同？

- 属性提供了更为强大的，灵活的功能来操作字段
- 出于面向对象的封装性，字段一般不设计为Public
- 属性允许在set和get中编写代码
- 属性允许控制set和get的可访问性，从而提供只读或者可读写的功能 （逻辑上只写是没有意义的）
- 属性可以使用 override 和 new（属性的本质是方法）





### 静态成员和非静态成员的区别？

- 静态变量使用 static 修饰符进行声明，**静态成员在加类的时候就被加载**（静态字段是随类型对象存放在Load Heap上的），通过类进行访问。
- 不带有static 修饰符声明的变量称做非静态变量，**在对象被实例化时创建**，通过对象进行访问 。
- 一个类的所有实例的同一静态变量**都是同一个值**，同一个类的不同实例的同一非静态变量**可以是不同的值** 。
- 静态函数的实现里不能使用非静态成员，如非静态变量、非静态函数等。





### 自动属性有什么风险？

因为自动属性的私有字段是由编译器命名的，后期不宜随意修改，比如在序列化中会导致字段值丢失。





### 特性是什么？如何使用？

特性与属性是完全不相同的两个概念，只是在名称上比较相近。Attribute特性就是关联了一个目标对象的一段配置信息，本质上是一个类，其为目标元素提供关联附加信息，这段附加信息存储在dll内的元数据，它本身没什么意义。运行期以反射的方式来获取附加信息。使用方法可以参考：http://www.cnblogs.com/anding/p/5129178.html





### （C#中的闭包）下面的代码输出什么结果？为什么？

```C#
List<Action> acs = new List<Action>(5);
for (int i = 0; i < 5; i++)
{
    acs.Add(() => { Console.WriteLine(i); });
}
acs.ForEach(ac => ac());
```

输出了 5 5 5 5 5，全是5！因为闭包中的共享变量i会被提升为委托对象的公共字段，生命周期延长了

原因：这是因为 lambda 表达式中引用的变量 `i` 是一个外部变量，而不是 lambda 表达式的参数。当 lambda 表达式被创建时，它不会复制变量 `i` 的当前值，而是将其作为引用捕获。这意味着当循环继续迭代时，变量 `i` 的值会随之改变，所有已创建的 lambda 表达式都会反映这一改变。因此，当这些 lambda 表达式最终被调用时，它们都将输出变量 `i` 的最终值，即 5。如果要避免这种情况，可以将变量 `i` 复制到一个局部变量中，然后在 lambda 表达式中引用该局部变量，而不是直接引用循环变量 `i`





### C#中的委托是什么？事件是不是一种委托？

什么是委托？简单来说，委托类似于 C或 C++中的函数指针，允许将方法作为参数进行传递。

- C#中的委托都继承自System.Delegate类型；
- 委托类型的声明与方法签名类似，有返回值和参数；
- 委托是一种可以封装命名（或匿名）方法的引用类型，把方法当做指针传递，但委托是面向对象、类型安全的；

事件可以理解为一种特殊的委托，事件内部是基于委托来实现的。





### C#浅拷贝深拷贝

[(2条消息) 一文搞懂C#中的赋值、深复制、浅复制_c# 值赋值_LoveMIss-Y的博客-CSDN博客](https://blog.csdn.net/qq_27825451/article/details/81274668)











## 数据结构



### C#中所有引用类型的基类是什么

- 引用类型的基类是System.Object
- 值类型的基类是 System.ValueType
- 值类型也隐式继承（不需要指定，默认继承）自System.Object









### ArrayList和 List的主要区别

- 类型安全：ArrayList 不带泛型 类型不安全	List 带泛型 类型安全
- 拆装箱：ArrayList 需要装箱拆箱   List不需要
- 底层原因：ArrayList会把所有插⼊其中的数据都当做Object来处理，因此装箱拆箱的操作费时







### List底层结构

- List内部是用**数组**实现的
- List的Add，Insert，IndexOf，Remove接口都是没有做过任何形式的优化，都使用的是顺序迭代的方式，如果过于频繁使用的话，会导致效率降低，也会造成不少内存的冗余，使得垃圾回收(GC)时承担了更多的压力
- 需要扩容时每次扩容两倍
- 默认容量是4
- 尽量不要用foreach，因为 List 的 foreach 会增加有新的 Enumerator 实例，如果大量使用迭代器的话，就会造成大量的垃圾对象
-  List 的 Sort 排序的效率为O(nlogn)，**快速排序**
- List 的效率并不高，只是通用性强而已，大部分的算法都使用的是线性复杂度的算法，这种线性算法当遇到规模比较大的计算量级时就会导致CPU的大量损耗，线程也并不安全，需要加锁机制来保证线程的安全性



[《Unity3D高级编程之进阶主程》第一章，C#要点技术(一) - List 底层源码剖析 - 技术人生 (luzexi.com)](http://www.luzexi.com/2018/07/06/Unity3D高级编程之进阶主程-CSharp要点技术1)







### Dictionary底层构造

Dictionary 是以数组为底层数据结构的类，通过哈希桶来解决键值对的存储问题，采用拉链法

主要有两个数组，Entries[]和buckets[]

当存入第一个键值对时，先计算哈希值，然后对于容器大小取余，得到buckets的下标，bucket数组里存放的是指向entries的下标，entries[]从0开始存放，把哈希值，键值对，next（拉链法中指向下一个元素的位置）赋值

当存入一个元素的哈希发生碰撞时，将buckets[]数组中对应哈希值下标的元素改为新存入的键值对的entries，然后再将其next指向上一个键值对

扩容：

- 1、申请不小于当前大小两倍的最小质数（实际上是一个prime数组大小的buckets、entries
- 2、将现有的元素拷贝到新的entries
- 3、使用新HashCode函数重新计算Hash值
- 4、对entries每个元素bucket = newEntries[i].hashCode % newSize确定新buckets位置
- 5、重建hash链，newEntries[i].next=buckets[bucket]; buckets[bucket]=i;





[【C#】浅析C# Dictionary实现原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/96633352)



## C#特性



### 反射

 可以在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息，是在运行期动态获取类、对象、方法、对象数据等的—种重要手段

**反射的作用**：在Unity引擎中，我们希望通过一个统一的方式来处理不同的类或类的实例，否则每次开发者创建一个类，就需要修改引擎底层代码才能调用这个新的类，这是不现实的。

**类型描述对象实例（Type）**：每个类编译器都知道其地址，以及数据成员的偏移，成员函数在代码段中的位置。因此通过编译信息，我们可以生成描述这个类的对象实例，这样底层就可以构建实例，调用成员和方法

优点：
        允许在运行时发现并使用编译时还不了解的类型以及成员。

缺点：

​	1.根据目标类型的字符串搜索扫描程序集的元数据的过程耗时。

​	2.反射调用方法或属性比较耗时。（首先必须将实参打包成数组，在内部，反射必须将这些实参解包到线程栈上。可以使用多态避免反射操作）



# 计算机网络



## Socket是什么



​		socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用，从而实现进程在网络中通信。 

![这里写图片描述](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/socket2.jpg) 

​		在设计模式中，Socket其实就是一个门面模式，**它把复杂的TCP/IP协议族隐藏在Socket接口后面**，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。所谓的socket编程，只要熟悉这些接口即可。

​		Socket的英文原义是“插座”（还有其他含义，但是当初网络变成起名为socket主要是借用了插座的概念）。通常也称作”套接字”，**主要用于解决网络进程间通信。** 
　　两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程。我们知道IP层的ip地址可以唯一标识主机，而**TCP层协议和端口号可以唯一标示主机的一个进程**，这样我们可以利用**ip地址＋协议＋端口号唯一标示网络中的一个进程**。 
　　Socket是面向”客户/服务器“（C/S）模型而设计的，针对客户和服务器程序提供不同的Socket系统调用。这种模式巧妙地解决了进程之间建立通信连接的问题。服务器Socket会公告给需要通信的一方。 
　　不妨考虑一下，两个完全随机的用户进程之间如何建立通信？假如通信双方都不知道对方的socket编号，就好比打电话的双方彼此不知道对方的电话号码，要通话是不可能的。采用了C/S模式后，由client端发起请求，server端接收请求，并应答，从而建立好链接。 
　　可以通过下图理解一下socket链接的建立过程 
　　![这里写图片描述](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/socket3.jpg)

　　还可以通过一个生活中常见的事情做一个比喻：你要打电话给一个朋友，先拨号（这个号肯定提前已知，在这个例子中，被叫方可以当做server端来理解），朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。







## Socket粘包什么是粘包?

顾名思义，其实就是多个独立的数据包连到一块儿。

### 什么情况下需要考虑粘包?

如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构:
1 )"good good study"
2)"day day up"
那这样的话，如果发送方连续发送这个两个包出去，接收方一次接收可能会是"good good studyday day up”这样接收方就傻了，因为协议没有规定这么奇怪的字符串，所以要把它分包处理，至于怎么分也需要双方组织一个比较好的包结构，所以一般可能会在头加—个数据长度之类的包，以确保接收。

所以说:**Tcp连续发送消息的时候，会出现消息一起发送过来的问题，这时候需要考虑粘包的问题。**

### 粘包出现的原因(在流传输中，UDP不会出现粘包，因为它有消息边界。)

1.**发送端需要等缓冲区满才发送出去**，造成粘包(发送端出现粘包)

⒉**接收端没有及时接收缓冲区包数据**，造成一次性接收多个包，出现粘包(接收端出现粘包)

### 解决粘包

1.缓冲区过大造成了粘包，所以在发送/接收消息时**先将消息的长度作为消息的一部分发出去**，这样接收方就可以根据接收到的消息长度来动态定义缓冲区的大小。(这种方法就是所谓的自定义协议，这种方法是最常用的)（长度+数据的封包方式）

2.对发送的数据进行处理，每条消息的**首尾加上特殊字符**，**然后再把要发送的所有消息放入一个字符串中**，最后将这个字符串发送出去，接收方接收到这个字符串之后，**再通过特殊标记操作字符串，把每条消息截出来**。(这种方法只适合数据量较小的情况)（消息分隔符的封包方式）

注:要记住这一点:TCP对上层来说是一个流协议，所谓流,就是没有界限的一串数据.大家可以想想河里的流水,是连成一片的其间是没有分界线的，也就是没有包的概念。所以我们必须自己定义包长或者分隔符来区分每一条消息。







## Socket的封包、拆包

### 基于TCP的通信程序需要封包、拆包的原因

   TCP是流协议，所谓流，就是没有界限的一串数据。但是程序中却有多种不同的数据包，那就很可能会出现如上所说的粘包问题，所以就需要在发送端封包，在接收端拆包。

### 那么如何封包、拆包

​        **封包就是给一段数据加上包头**。比如上面解决方法1中，将消息的长度作为消息的一部分发出去，然后根据消息长度动态定义缓冲区大小的过程就是封包。在网络编程中，这个过程也被称为长度+数据的封包方式。

​		**拆包就是对需要对接收到的字符串进行解析，将其中的多条消息分隔出来，并对每条消息进行处理。**

​		长度+数据的封包和拆包方式：将消息的长度作为消息的一部分发出去，然后根据消息长度动态定义缓冲区大小，将消息头和消息体组合成一个完整的消息，并发送给接收方。在接收方进行拆包时，可以先从网络中接收到消息长度，然后根据消息长度分离出消息头和消息体，再对消息体进行处理。

​		消息分隔符的封包方式：对发送的数据进行处理，每条消息的**首尾加上特殊字符**，**然后再把要发送的所有消息放入一个字符串中**，最后将这个字符串发送出去，接收方接收到这个字符串之后，**再通过特殊标记操作字符串，把每条消息截出来**。





## TCP和UDP的区别

![image-20230408142647501](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/image-20230408142647501.png)

TCP：

- 面向连接的传输层协议
- TCP连接只能有两个端点，所以只能点到点连接
- 提供可靠服务，可靠有序，不丢不重
- 全双工通信
- 面向字节流：TCP把应用程序交下来的数据看成仅仅是一连串的无结构字节流（流就是字节序列）
- 首部开销20B起
- 有流量控制和拥塞控制

![20160916110125505](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/20160916110125505.png)

UDP：

- 无连接，减少开销和发送时延
- 不保证可靠性
- 面向报文，适合一次性传输少量数据
- 无拥塞控制
- 首部开销小，8B

![20160916110144427](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/20160916110144427.png)











## UDP的可靠性封装

最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。

- 1、**添加seq/ack机制**，确保数据发送到对端
- 2、**添加发送和接收缓冲区**，主要是用户超时重传。
- 3、**添加超时重传机制**。

详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。

目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。

1、RUDP（Reliable User Datagram Protocol）

**RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等**，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。

2、RTP（Real Time Protocol）

**RTP为数据提供了具有实时特征的端对端传送服务**，如在组播或单播网络服务下的交互式视频音频或模拟数据。

应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。

RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。

3、UDT（UDP-based Data Transfer Protocol）

基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。**UDT的主要目的是支持高速广域网上的海量数据传输**，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。

顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。





## TCP三次握手

![image-20230408150927001](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/image-20230408150927001.png)

SYN：同步位，在第一次和第二次握手时为1

seq：消息的序列号

ACK：确认位

ack：与ACK同时出现，表示期待接收的下一个序列号





## TCP四次挥手

![image-20230408151354964](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/image-20230408151354964.png)

FIN：结束位





## TCP第四次挥手为什么要等待2MSL？

1、为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

2、他还可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。









# Lua



## Table

- 索引从1开始
- 先将显示索引赋值，再给隐式索引赋值，如果遇到同一索引已经赋值则会把原来的值覆盖
  - 因此显示索引必须大与隐式索引
  - eg.`loacal mytable={1,2,[3]=4,3}`此时table值应该为`{1,2,3}`
- table是什么样的数据类型？
  - table同时支持**索引存储**和**键值对（KV）**存储
  - 注意：通过键值对定义的元素无法通过索引访问到
  - 索引访问`mytable[1]`   键值对访问`mytable.a`
- table可以作为table的元素
- func可以作为table的元素
- nil也占一个索引位`loacal mytable={1,2,nil,3} --mytable[4]为3`
- 空表也存在地址
  - `local mytable`返回nil    `local mytable={}`返回空表的地址
  - 判断是否为空表 `next(mytable) == nil` 通过判断第一个位置是否有值来确定
- table长度获取方式：`#mytable`  or  `table.getn(mytable)`
  - 无法获取到键值对的数量
  - table中如果存在nil时结果则不确定，可能读到nil就停止也可能会继续读取
- pairs和ipairs的区别？
  - pairs遍历可以忽略nil，并且也**可以遍历键值对**的元素（功能更强）
  - ipairs遍历到**nil就会停止遍历**，并且**不能遍历键值对**元素



## 元表

__index元方法

- 访问了原来的表中没有的元素时会调用__index元方法
- `__index = { b = 6 }`如果原来的表中没有符合的，就会在原方法中寻找元素
- `__index = function(table, key)  end`  如果原来的表中没有符合的，就会调用元方法的函数
  - 注意：table代表设置元方法后的表，key为访问时的键值，这两个参数是默认的，不传入仍然会存在，但是会影响可读性

__newindex元方法

- 新增了原来的表中没有的元素时会调用__newindex元方法，并且不会进行新增复制操作
- `__newindex = function(table, key, value)  end`元方法函数中多了一个默认参数value
- 一般用于限制添加新元素

__call元方法

- 把表作为函数进行调用时会调用__call元方法
- eg. `mytable(newtable)`  这里传入的参数可以是任何类型
- `__call = function(table, newtable)  end`元方法函数中默认参数是table本身和参数

__tostring元方法

- 在使用tostirng函数将一个对象转换为字符串时，或者当使用 `print` 函数打印一个对象时，会调用__tostring元方法

：和 . 调用

- `function mytable:test(p)  end`冒号调用时会自动把表自己(self)作为参数传入
- 点调用时不会把自己作为参数



## 闭包

理解前提：

- function在lua里面是变量，可以相互赋值，可以作为参数传递
- function在lua中可以是匿名方法
- function定义时可以像赋值一样进行定义
- function允许运行期创建，也叫**第一类值**
- 语法域，词法定界：一个函数可以嵌套在另一个函数中，内部函数可以访问外部函数的局部变量

闭包的定义： 

- lua 编译一个函数的时候,  会生成一个 原型 prototype.  其中包含了函数体对应的虚拟机指令（嵌套的函数）,函数体中的常量, 和一些调试信息. 
- 运行的时候, 当lua执行 function <body> end ,会创建一个新的数据对象,  对象中包含了相应函数原型的引用以及一个数组 (包含了所有upvalue的引用)。 这个数据对象,称为闭包.
- upvalue：在外部函数体内，或者作为外部函数的参数；与嵌套的函数平级；既不是闭包的临时变量,也不是全局变量,  而是非全局变量

闭包的作用：

- 高阶函数的参数 

  - `table.sort(t , function(t1,t2) return t1.param > t2.param end )`
  - 解释：闭包可以访问到他的upvalue `t`

- 重写 (类似于 C# 面向对象的重写 )

  ```lua
  -- 案例 io.open 
  
  local oldOpen  = io.open
  
  local  accessOk = function (filename , mode)
  
  ​       --  检查文件 校验文件方法
  
  end 
  
  io.open =  function (filename, mode )
  
  ​        if accessOK(filename, mode) then 
  
  ​             return  oldOpen(fiename, mode)
  
  ​        else 
  
  ​              return nil ," 校验失败"
  
  ​        end
  
  end
  ```

  - 解释：通过闭包的形式调用`accessOK`和`oldOpen`方法，实现对`io.open`的重写

- 实现迭代器 

  ```lua
  function values(t)
  	local i = 0
  	return function () i = i + 1 return t[i] end
  end 
  t = { 10,20,30,40,50,60} 
  iter = values(t)  
  ```



## C#和Lua相互调用的问题

- Lua用C开发
- C和Lua可以直接通讯
- 提供一系列调用接口，让C和Lua相互调用



- C# 如何和lua调用？

  - C# 调用C, C语言调用lua

  - XLUA插件, 封装了一层 C#调用C语言的接口 





## _rawset与_rawget的区别

​    _rawget:访问时，不想从__index 对应的元方法中查询值

​    _rawset:更新时，不想执行__newindex 对应的元方法





## 为什么用Lua热更新？



- 高效：指的是脚本语言执行高效，在解释Lua时不是翻译为机器码，而是使用C代码进行解释，不用开辟可执行权限的内存空间，也不会有新代码执行，执行解释的是用C语言写出来的虚拟机
- 轻量：指的是脚本语言很容易嵌入游戏引擎，同时脚本的体系不大，没有过多的与语言本身无关的系统和库内置在里面







# Git



## 如何解决Git中的冲突？

- 识别造成冲突的文件。
- 对这些文件进行所需的修改
- 使用 git add 命令添加文件到暂存区。
- 最后一步是在git commit命令的帮助下提交文件的修改。





## git remote和git clone什么区别？

git remote add在你的git配置中创建了一个条目，指定了一个特定URL的名称，需要有一个现成仓库提前Init

git clone通过复制位于该URL的现有仓库来创建一个新的git仓库。不需要现成仓库





## reset和Revert的区别是什么？

- Git reset 是一个强大的命令，用于撤销对 Git 仓库状态的局部修改，将你的索引以及工作目录重置为你最后一次提交的状态，Git 重置的操作对象是 "Git 的三棵树"，即：提交历史（HEAD）、暂存索引和工作目录。
- Git的Revert命令创建了一个新的提交，撤销了前一个提交的修改。这个命令为项目添加了一个新的历史。它并不修改现有的历史。



## git fetch&git pull详解

git fetch的意思是将远程主机的最新内容拉到本地，用户再检查无误后再决定是否合并到工作本地分支中。

git pull 是将远程主机中的最新内容拉取下来后直接合并，即：git pull = git fetch+git merge，这样可能会产生冲突，需要手动解决。





## Git stash存储的目的是什么？

Git stash 获取工作文件和索引的当前状态并放入堆栈以供下一步使用，并返回一个干净的工作文件。因此，如果在对象中间并需要跳转到其他分支去处理，同时不想丢失当前的编辑，可以使用 Git stash。







## 说说GIT合并的方法以及区别？

Git代码合并有两种：git merge 和 git rebase

git merge：merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容，它会比对双方不同的文件缓存下来，生成一个commit，去push。

git rebase：这种合并方法通常被称为“衍合”。 他并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面他是提交修改历史。











# Unity





### AssetBundle相关知识

把资源导出成一种叫做AssetBundle的文件，然后打包后可以在Unity程序运行的时候再加载回来用。
AssetBundle是采取某一种压缩方式压缩成的资源文件。节省存储空间，控制游戏包的大小，实现游戏的热更新。

[(5条消息) Unity AssetBundle_unityengine crc_张伟林_VillainJan的博客-CSDN博客](https://blog.csdn.net/a834595603/article/details/91346559)

[(5条消息) Unity3D:资源包的压缩(Asset Bundle Compression)_unity3d项目压缩_张小亮QAQ的博客-CSDN博客](https://blog.csdn.net/zgl159040290/article/details/52806507)







### Invoke和InvokeRepeating&Coroutine	物体被隐藏后还会被调用嘛？



**Invoke** 方法是 Unity 的一种委托机制。表示几秒后调用方法。InvokeRepeating是几秒后调用，之后每几秒调用一次

注意：

- 它应该在脚本的生命周期里的（Start、Update、OnGUI、FixedUpdate、LateUpdate）中被调用；
- Invoke 不能接受含有参数的方法；
- 在 Time.ScaleTime = 0 时， Invoke 无效，因为它不会被调用到，另外，Invoke 也支持重复调用；
- 脚本被禁用后，物体隐藏后都仍然继续执行



**协程**是一个分步执行，遇到条件（yield return 语句）会挂起，直到条件满足才会被唤醒继续执行后面的代码。 Unity 在每一帧都会去处理对象上的协程。Unity 主要是在 Update 后去处理协程（检查协程的条件是否满足）。

作用

- 延时（等待）一段时间执行代码；
- 等某个操作完成之后再执行后面的代码，总结起来就是一句话：控制代码在特定的时机执行。

注意：协程不是线程，也不是异步执行的。协程和 MonoBehaviour 的 Update 函数一样也是在 MainThread 中执行的。使用协程你不用考虑同步和锁的问题。

- 在程序中调用 StopCoroutine() 方法**只能终止以字符串形式启动(开始)的协程**；
- **多个协程可以同时运行**，它们会根据各自的启动顺序来更新；
- 协程可以嵌套任意多层；
- 如果你想让多个脚本访问一个协程，你可以定义静态的协程；
- **协程不是多线程**（尽管它们看上去是这样的），它们运行在同一线程中，跟普通的脚本一样；
- 如果你的程序需要进行大量的计算，那么可以考虑在一个随时间进行的协程中处理它们；
- IEnumerator 类型的方法不能带 ref 或者 out 型的参数，但可以带被传递的引用；
- 目前在 Unity 中没有简便的方法来检测作用于对象的协程数量，以及具体是哪些协程作用在对象上。
- **MonoBehaviour.enabled = false 协程会照常运行，但 gameObject.SetActive(false) 后协程会全部停止**，即使在 Inspector 面板 把 gameObject 激活也不会继续执行。





**Invoke**：执行没有被挂起，相当于设置完被调用函数的执行时间后，即时向下执行，适用于每隔一段时间执行某个函数。

**Coroutine**：新开一条执行序列（跟新建线程差不多）并挂起，等待中断指令结束，开销不大，当需要挂起当前执行时使用。













如何区别上个版本和这个版本的区别（可选）

整包，分包策略

版本号管理

UGUI









层级管理







### 相机渲染顺序

相机在渲染顺序上的位置。具有较低深度的相机将在较高深度的相机之前渲染。也就是说depth越高，界面窗口的显示越靠前









### image和rawimage

RawImage核心代码比Image少很多，Raw Image不支持交互，可用于显示任何图片而不仅仅是Sprite，一般用在背景、图标上,支持UV Rect(用来设置只显示图片的某一部分)，本质上取得就是这个资源的Texture，其他的属性它都不关心

Image组件的Source Image指向的资源类型是Sprite，Image的代码实现更为复杂，功能也更为丰富，在image组件里，我们可以实现资源的不同的Image Type，可以交互，大多应用于某个ui的图片显示或者说是一些小图，比如我们刚说的需要拉九宫的图以及用作进度条和倒计时的图





怎么显示3d模型在UI上







### mask和rectmask2d区别？底层？

rectmask只能做矩形的遮罩；mask可以做任意形状的遮罩

mask需要依赖Image组件；rectmask不需要依赖

性能上rectmask本身不会增加drawcall，只会增加一个Image的drawcall；mask有首尾两个节点，再加上被遮挡的Image，会增加次drawcall

不同的mask可以合批，但是前提是渲染层级，材质，图集相同；不同的rectmask不能合批

[【Unity源码学习】遮罩：Mask与Mask2D - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/136505882)





背包中1000个道具？10000道具？卡不卡？







### IL2CPP和Mono



**Mono：**

- 微软.Net标准的跨平台项目，可以基于Mono来跨平台的开发应用和引擎，并且打包发布到各个平台上
- Unity设计之初基于Mono作为底层，实现Unity编辑器以及打包的引用的跨平台功能

**Mono的问题**

- Mono涉及到.Net的版权问题
- Mono虚拟机解释.Net字节码效率不够高
- 部分平台不支持内置Mono.Net虚拟机
- 对于新的平台，维护成本太高，不方便移植

**IL2CPP：**在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的机器码

- 底层的不同平台的运行时库（runtime），生成对应平台的应用程序
- Unity引擎和游戏代码传换成.Net字节码，再通过il2cpp工具，变成C++代码
- C#的特殊机制（垃圾回收等）通过il2cpp vm（runtime）来实现支持

**IL2CPP的优势**

跨平台可移植性更强：只需要移植il2cpp，解决了.Net版本的问题

性能获得提升：转成C++代码执行性能更好，C++会做编译优化



注意：IL2CPP只支持AOT方式，Mono支持AOT，JIT所有方式
平台支持：Android平台支持Mono和IL2CPP的所有编译方式，而IOS只支持Mono的Full AOT模式和IL2CPP 







### 进程，线程，协程

- 其实很简单，首先需要理解进程和线程是怎么一回事：进程是Windows系统中的一个基本概念，他包含着运行一个程序所需要的基本资源。一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。　　
- 进程和线程的区别通过以上，一目了然。　　
- 再谈谈线程和协程的区别。一般应用一个应用程序只使用线程这一“资源”。
- 需要明确，Unity只使用了一个线程，但是，我们需要”同时做很多事“，那Unity作为单线程，该如何去做，协程，就来了，协程是一种”伪线程“。 协同程序（coroutine）.,即协作式程序，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协成处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CPU进行分时，协程可以访问和使用unity的所有方法和component。　　　　
- 同一时间只能执行某个协程，协程适合对某个任务进行分时处理。　　　　
- 控制代码在特定的时间执行。　　　　
- 协程不是线程，也不是异步执行，跟Update一样，在主线程中执行。　　　　
- 不用考虑同步和锁的问题。　　　　
- 协程是一个分部组件，遇到条件（yield return）会挂起,直到条件满足才会被唤起执行后面的语句。





# 性能优化





### drawcall是什么？  优化drawcall

- CPU会将数据先放入缓存区，然后CPU向GPU发布一条渲染指令，就是一次DrawCall的过程
- drawcall次数影响CPU性能
- 合批：把一些相同的数据，整合在一起，批量交给GPU去处理，**层级、纹理、渲染方式，当这三者都相同的时候，就会合批（Batch）**

#### 优化drawcall

**静态合批**：

- 将static的静态物体（永远不会移动、旋转和缩放） ，如果相同材质球，面数在一定范围之内。unity会自动合并成一个batch送往GPU处理；
- 优点： 因为只需要进行一次，所以性能会比动态批处理要好；缺点：需要静态，大量网格体内存开销大；
- 在预处理阶段，把一些材质相同的模型的顶点统一变换到世界空间坐标下，并且新构建一个大的VB把数据保存下来，在绘制时，就会把这个大的VB提交上去，只需要设置一次渲染状态，再进行多次drawcall绘画出每个子模型。 所以Static Batching是不会减少drawcall的，但由于只修改了一次渲染状态依然可以减少CPU的消耗。而且在渲染前，也可以进行视锥体剔除，减少顶点着色器对不可见的顶点的处理次数，提交GPU的效率。
- **静态合批发生在加载场景的时候**

**动态合批**：

- 如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。
- Unity会检测哪些GameObject使用了同一个共享材质，然后去合并这些使用了同一个共享材质的网格顶点数据，形成一个新的大网格，然后传给显存，直接渲染这个大网格就相当于渲染了所有的被合并的小网格，而这只需要一次DrawCall。在每一帧运行时，计算相同材质的模型，把他合并批次进行渲染。动态合批只需要设置一次渲染状态，且能减少drawcall次数。
- 需要CPU去计算网格顶点，因此需要权衡CPU增加的开销和优化的性能
- **动态合批发生在游戏运行的时候**

**GPU Instancing：**

提交一个物体，GPU在渲染时渲染N个实例，然后在绘制到场景中不同的N个位置上（同一个物体不同的实例）







### overdraw优化

- Overdraw是指屏幕上的某个像素在同一帧的时间内被绘制了多次。
- 过多Overdraw可能会引起GPU过载，影响动画的播放和界面响应速度

1. 将Mask（自带两层Overdraw）**替换为RectMask2D**（自带一层Overdraw）
2. 全屏遮挡的情况，则为被遮挡的canvas添加CanvasGroup 组件，然后在被挡住时将其alpha值设为0，不参与绘制，没有 DrawCall也没有Overdraw，同时顶点也不会参与重绘。
3. unity的文字显示中自带阴影组件**shadow/Outline减少使用**，自带overcall。
4. UI摆放，减少UI的叠加效果。
5. **将不想显示的物体直接禁用**，而不是将其透明度改为0，仍会产生overcall。









### 图集什么用？

它是一种将多个纹理合并为一个组合纹理的资源。Unity 可以调用此单个纹理来发出单个绘制调用而不是发出多个绘制调用，能够以较小的性能开销一次性访问压缩的纹理。





### 图集里两个图片一定会合批吗？

不一定，需要相同的材质才会合批













# 设计模式

## 面向对象8大设计原则

1. 依赖倒置原则：高层模块（稳定）不能依赖于低层模块（不稳定），而是让高级模块依赖于抽象（稳定），同时低级模块依赖于抽象去实现具体细节，而抽象不能依赖实现细节
2. 开闭原则：对扩展开放，对修改封闭
3. 单一职责原则：一个类只能有一个引起他变化的原因（只有一个职责），变化的方向隐含着类的职责
4. 里氏替换原则：子类必须能够替换他们的父类（IS-A关系），继承表达类型抽象
5. 接口隔离原则：接口应该小而完备，不应强迫客户程序依赖他们不用的方法
6. 优先使用对象组合，而不是类继承：继承某种程度上破坏的封装性，子类父类耦合度高
7. 封装变化点：使用封装来创建对象的分层，使得能够修改一侧而不影响另一侧，实现松耦合
8. 针对接口编程，而非针对实现编程：不将变量声明为某个特定具体类，而是声明为接口/抽象类（就是依赖倒置原则）





## 单例模式

- 区别类中的成员变量
  - 通过类名直接访问（类成员）
  - 通过创建对象后才能访问（对象成员）

- 几种关键字修饰类中成员变量的区别
  - const：编译时常量，通过类名直接访问
  - readonly：运行时常量，通过创建对象后才能访问
    - 类当中的成员变量的创建和赋值代码实际上就是在构造中才执行，因此readonly可以在构造中赋值
  - static：静态，通过类名直接访问
  - staic readonly：运行时静态常量，通过类名直接访问

- 单例模式：在类中包含一个与自身类相同的，通过类名直接访问的成员（一般为static）

- 特点：全局唯一，不需要第二个实例

  - 懒汉模式：初次访问Instance时实例化

    - 优点：节省性能开销，适用于提供外部大量方法的接口的类
    - 缺点：**不适用于提供外部大量数据的类，线程不安全**
    - 解决线程安全的方法有很多，详见[C#实现单例模式的几种方法 - xiaohanxixi - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaohanxixi/p/13197362.html)，下面也会列出几种常用的变种

    ```c#
    public class GameManager
    {
        private static GameManager instance;//与自身类相同的，通过类名直接访问的成员
    	public static GameManager Instance
    	{
    		get 
        	{
    			if (instance == null)
            	{
            		instance = new GameManager
        		}
    			return instance;
    		}
    	}
    }
    
    
    
    /*变种1 不完全懒汉式，但不加锁的线程安全 */
    public sealed class Singleton4
    {
        private static readonly Singleton4 instance = new Singleton4();
    
        /// <summary>
        /// 显式的静态构造函数用来告诉C#编译器在其内容实例化之前不要标记其类型
        /// </summary>
        static Singleton4() { }
    
        private Singleton4() { }
    
        public static Singleton4 Instance
        {
            get
            {
                return instance;
            }
        }
    }
    
    
    
    /*变种2 Lazy<T>(Func<T>)
    	通过Lazy关键字，我们可以声明某个对象为仅仅当第一次使用的时候，再初始化，如果一直没有调用，那就不初始化，省去了一部分不必要的开销，提升了效率，同时Lazy是天生线程安全的
    	Func<T>内容的主要作用是初始化T类型对象时需要执行的逻辑，一般使用lambda表达式
    */
    public sealed class Singleton6
    {
        private static readonly Lazy<Singleton6> lazy = new Lazy<Singleton6>(()=> new Singleton6());
    
        public static Singleton6 Instance { get { return lazy.Value; } }
    
        private Singleton6() { }
    }
    ```

  - 饿汉模式：在初始化方法中实例化，并且我们主动去调用初始化方法

    ```c#
    public class GameManager
    {
        public static void InitManager()//初始化静态方法
        {
            instance = new GameManager
        }
        private static GameManager instance;
        //上述代码也可以替换为下面一行，在类被构建，私有构造被调用时就实例化，保证之后调用时单例已经存在
        //private static GameManager instance = new GameManager();
    	public static GameManager Instance
    	{
    		get 
        	{
    			return instance;
    		}
    	}
    }
    ```

- 注意：项目中单例模式数量不能太多，否则维护困难

  - 在项目中一些全局唯一的元素可以在对应的单例管理器中通过Dictionary的形式进行管理



## 工厂模式

​	通过使用一个共同的接口来指向新创建的对象，并且创建对象时不会对用户暴露创建逻辑

简单工厂模式

- 由一个工厂对象决定创建出哪一种产品类的实例
- 如需要创建两个职业角色Warrior和Archer，创建一个工厂类，开放一个方法，通过职业判断执行创建对应职业角色的逻辑

工厂模式

- 将具体的创建工作放在了具体子类的工厂中进行
- 接着上个例子，给两个职业分别创建一个工厂，同时继承于一个父类，根据需要的职业在对应的职业工厂中创建角色的逻辑

抽象工厂模式

- 简单工厂的进一步抽象，将简单工厂就变成了工厂族，更利于代码的维护和扩展。
- 需求上增加不同种族的不同职业，根据种族创建对应的工厂，再分别创建两个职业对应的工厂继承种族工厂，根据职业在对应的工厂中创建需要的种族的职业角色的逻辑
- 缺点：如果要增加种族，就需要重写基类，不符合开闭原则



## MVC

MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。

用一种业务逻辑、数据、界面显示分离的方法，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。

- Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。
- View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。
- Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据

从 MVC 模式的一般理解来看，视图层与模型层是存在直接联系的，并且模型层的变化会通过视图层反映出来，这确实是 MVC 模式的标准理解，不过在我目前接触到的实际应用中，更多的情况是，视图层与模型层是通过控制层联系起来的，两者之间并无直接的联系，三者之间的关系更类似下图所示：

![img](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/20190129103002278.png)

优点：耦合低，重用性高，利于维护

缺点：不适合小项目









# 项目准备





## MMO

### 道具系统

道具配置表数据结构：key，id（两者相互对应，用于把数据存到字典中），以及各类道具属性

道具协议数据结构：id，数量，拥有者

道具系统的设计模式是一个类似于MVC结构的形式；

Model层负责数据的处理，包括服务端在收到客户端的请求以后需要修改数据库对应的数据，客户端需要能够读取配置文件中的数据作为实例化的对象

Visual层主要是UI界面的展示和UI的逻辑，并借助Model层对UI的数据进行更新和修改；在一开始做道具系统的时候还没有实际的UI部分，**在之后的背包和商店当中，就会涉及到**

Controller层在道具系统中使用Manager层来代替，实际上功能是基本相同的，在服务端和客户端都是主要维护一个道具字典，以及负责完成一些操作的逻辑功能在道具系统中主要是添加/删除道具的功能；服务端和客户端Manager的主要区别在于：服务端的Manager需要对应到角色上，因为服务端有许多角色，而客户端只有玩家一个角色因此不需要对应

还有一个Service层在服务端和客户端都是主要负责发送道具变更的消息，以及消息触发回调

在我们这个道具系统中，道具变更消息的接收主要依靠一个状态系统来完成，主要功能是把服务端的数据变化返回给客户端的消息与其他消息一起发送出去，相当于被动发送，这样就可以节省发包的次数，同时也解决了一个请求需要发送多个响应回去的问题。具体来说，需要返回给客户端的数据会首先进行缓存，当有其他主动发送的数据发送前，会判断缓存里是否有需要发送的状态，然后连同主动发送的消息一起打包到一个数据中，发送到客户端，客户端根据不同的状态触发不同的回调。

道具系统的整个流程大致是：在UI界面上触发道具的变更，发送消息到服务端，服务端的道具Manager层处理变更的逻辑以及校验的工作，完成后给客户端发消息，客户端收到消息后在Manager执行对应的更改操作，并将结果在UI上展示。





### 背包系统

背包的协议数据结构：

- 二进制数组表示背包内容，四个字节代表一个物品，前两位表示id，后两位表示count；
- 背包解锁的个数

背包系统是依赖于道具系统的，类似于一个展示层

同样是MVC的结构形式

Viusal层：

- 背包的UI，以及背包UI的一些逻辑功能，包括初始化界面，整理背包，页面切换；
- 初始化界面通过先获取到槽位，然后根据角色已有的道具将BagItem实例化到槽位上；
- 整理背包的主要逻辑在Manager中
- 页面切换通过TabView和TabButton实现，切换界面并修改按钮样式

Model层：BagItem以结构体的形式而非类的形式设计数据结构，主要是因为可能需要涉及到背包的物品交换，值类型方便直接用=交换，以及解析二进制的背包信息时方便使用指针赋值（如果是类指针赋值时是浅拷贝）；还重写了部分运算符，便于判断两个BagItem之间的关系

Manager层：主要实现了初始化背包数据，整理背包功能，添加道具功能；维护了背包的内容数组；在客户端不单独维护背包数据，因为背包内的道具和道具系统中的是相同的

- 初始化背包分为两种情况：如果服务端返回了背包数据，则解析服务端的背包数据；否则使用客户端的道具Manager的数据（都是在进入游戏时赋值的）
- 整理背包算法：数量小于一个格子的上限时直接赋值，如果大于时先减去格子上限的数值，并赋值后，在下一个格子循环判断是否小于格子上限，直至小于格子上限后直接赋值
- 添加道具：也需要先判断能不能直接加到一组还是需要拆分；添加道具会在道具系统当中的添加道具中调用（服务端已经确认好道具添加了）
- 进阶问题：增加一个需求：我可能会有消耗品、武器、道具等等，玩家可能想筛选出某一类的物品，你怎么制作？
  - 根据物品的类型，在遍历的时候判断类型是否为选择类型，符合的显示
- 进阶问题：那我现在每一个物品的优先级可能不一样，也就是物品在背包里面的位置不一样，你怎么设计呢？
  - 对物品在配置表设置优先级，在实例化前先排序

Service层：Bag只涉及到将背包数据保存到数据库中，背包数据作为角色属性在进入游戏时返回



### 商店系统

商店配置表：key，商店的id（在NPC中的参数来对应NPC和商店的关系)

商店道具配置表(对应不同商店中的道具）：key1用于对应哪个商店，key2用于对应商店里的道具id，道具id，以及道具的属性

协议上沿用道具系统

Model层：借用之前道具系统中的Item，包括客户端和服务端

Visual层：

- 商店UI：初始化商店列表；选择商品并购买
- 商品UI：初始化商品UI内容；实现ISelectHandler接口来实现选中的逻辑，包括替换贴图，以及设置数据状态
  - 商品UI告诉商店UI当前选中哪个商品，商店UI告诉商品实例化的信息

- 商店UI初始化时的数据获得在Manager层，UI主要负责根据数据实例化的功能
- 通过配置表数据初始化商店内容，UI实例化过程同背包系统
- 购买逻辑：根据选中的商品，调用Manager层（严格讲应该是Service层）向服务器发送购买请求

Manager层：

- 订阅NPC事件，NPC打开商店事件触发后，根据配置表的数据初始化对应商店
- 向服务器发送购买请求
- 服务端Manager中的购买逻辑：根据配置表判断请求的道具是否合法，然后减去金币，添加道具，保存到服务器，返回结果
  - 注意：添加道具的逻辑，通过之前的道具系统内的逻辑实现，并通过状态系统返回结果，因此客户端在收到购买结果后，不需要商店系统修改玩家道具，而是通过道具系统实现

Service层：

- 服务端：借用之前道具系统的Service，接收到消息后调用Manager逻辑，然后发送结果给客户端
- 客户端：接收结果，通过观察者模式重新刷新UI界面数据

商店系统中涉及到了金币的问题，金币作为角色属性，在服务端对角色实体执行金币减少的逻辑后，通过状态系统来返回给客户端



### 状态系统

状态系统的主要逻辑在服务端：当服务端发送数据前，会先判断是否有需要后处理的消息，将后处理列表中的消息与本来需要发送的消息一起打包，发送给客户端，这样做有两个目的：1.能够减少发包的次数	2.存在客户端一个请求，服务器需要同时返回多个不同的响应，这样能够解决这个问题

状态系统数据结构：

​	传输状态信息的协议数据结构包括：状态类型（确定对金币，道具，经验等属性进行操作，定义在协议里作成枚举），id（操作道具时需要），value（操作的具体值），状态的行为（更新，增加，还是减少）

Manager层：

服务端：

- 维护一个状态列表；不同属性的修改都有添加状态到状态列表的逻辑；后处理方法用于将状态列表中的消息加入要发送的消息中（后处理方法在消息发送打包前进行调用）

Service层：

客户端：

- 通过一个委托字典来对应不同的状态要执行的回调，需要在对应的功能类（Manager）初始化中添加订阅
- 在收到状态消息后，根据传输过来的类型，触发对应的回调





## xLua简单框架

框架开发流程：Bundle构建，Bundle加载，Bundle更新，Lua与C#相互调用

### Bundle构建

- 查找BuildResources下的资源文件
- 将Unity路径，ab包的相对路径，依赖资源路径写入filelist文件，格式：文件路径名|bundle名|依赖文件列表（GetDependences函数）
- 使用Unity提供的BuildPipline.BuildAssetBundles进行构建（LZMA格式压缩）
- 构建到StreamingAssets只读文件夹下
- BundleBuild策略：
  - 按照文件夹打包
    - 优点：bundle数量少，小包模式首次下载快
    - 缺点：后期更新时，更新补丁大
  - 按照文件打包
    - 优点：更新补丁很小
    - 小包模式下首次下载稍慢



### Bundle加载

![image-20230301150743893](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/image-20230301150743893.png)

解析版本文件，获取文件信息：从版本文件中获取到资源信息，做成一个数据结构（BundleInfo）并保存成一个列表

加载bundle：检查该资源是否已经加载过，检查对象池中是否有，都不符合才通过AssetBundle.LoadFromFileAsync获取到bundle创建request，并对request的AssetBundle单独做成一个带引用个数的数据结构（BundleData）进行缓存

检查依赖：递归的对依赖文件进行加载

加载资源：对获取到的BundleData通过AssetBundle.LoadAssetAsync获取到实际资源

回调：返回资源并调用回调



[用AB包异步加载资源（AssetBundleCreateRequest 和 AssetBundleRequest）_FragrantPig的博客-CSDN博客](https://blog.csdn.net/FragrantPig/article/details/112251004)



### Bundle更新（热更新流程）

![image-20230301151925187](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/image-20230301151925187.png)

释放包内资源：将Application.streamingAssets拷贝至Application.persistentDataPath

![image-20230301152735704](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/image-20230301152735704.png)

![image-20230301160821373](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/image-20230301160821373.png)



热更新基本流程：对比本地的filelist和资源服务器上的filelist，对比md5码的不同

1. 启动游戏。
2. 判断是否是初次安装：可读写目录的filelist（MD5文件）不存在，且只读目录的filelist存在；如果是初次安装，则释放包内资源（对于整包来说是这样，对于分包来说没有可以释放的资源，不需要判断是否初次安装，直接下一步）
3. 根据当前版本号，和平台号去版本服务器上检查是否有热更。
4. 从热更服务器上下载 MD5 文件，比对需要热更的具体文件列表。
5. 从热更服务器上下载需要热更的资源，解压到热更资源目录。
6. 游戏运行加载资源，优先到热更目录中加载，再到母包资源目录加载。



- 注意：在释放资源时，最后写入filelist，防止玩家更新到一半退出导致错误判断



热更新方案：

- 整包（热更新资源与安装包一起下载）
  - 优点：首次更新少
  - 缺点：安装包下载时间长，首次安装久
- 分包（热更新资源在安装后下载）
  - 优点：安装包小，下载时间短，安装快
  - 缺点：首次更新时间久

![img](https://jupiter-typora-pic.oss-cn-shanghai.aliyuncs.com/NDP4I4R_17@2%7DZPFUVYI5SV.png)



### Lua与C#相互调用的系统框架

根据我们需要的资源，分别搭建管理器



#### Lua

如果上一个语句获取lua脚本，下一个语句就需要执行lua的内容，基本很难实现，因此Lua加载需要**通过预加载实现异步加载，同步使用**；

预加载实际上在开始时就执行，将所有lua脚本读到缓存中；

在Manager中有不同模式下的加载Lua脚本方法，从缓存中获取Lua脚本并加载（触发require），初始化；以及维护了缓存lua脚本的字典，lua名称的列表

GameStart时调用Main的Lua脚本的具体流程：

- 解析版本文件时填充lua名称列表，初始化时通过lua名称列表预加载Lua脚本到缓存字典；
- 被加载时从缓存中加载Lua脚本，并通过自定Loader按照指定目录去缓存中加载，并执行（主要因为直接require需要在Resources目录下且后缀固定）



#### 系统设计框架

所有系统分为两个部分：Manager和Behaviour

- Manager：包含对象的缓存，触发对象的实例化并调用对象Lua脚本逻辑的方法；这些方法**主要是给Lua调用的方法**
- Behaviour：MonoBehaviour的Lua版本，通过Lua脚本内的逻辑实现Unity的生命周期的函数（**C#调用Lua**），挂载在具体实例上
- Manager上的方法给Lua调用，被Lua调用后触发Unity中的实例化，以及Behaviour中对应的Lua逻辑



#### UI

- 加载UI
- 绑定和执行lua脚本
- UI对象管理（委托给对象池）
- 层级管理（UGUI特点：根据节点顺序渲染）
  - 界面类型
    - 一级界面
    - 二级弹窗
    - 三级弹窗
    - 特殊界面



打开一个UI的具体流程：在Lua的Main中调用C#中UIManager中的OpenUI，OpenUI根据该UI是第几次调用，先触发OnInit再触发OnOpen（模拟了Awake和Start的关系来触发Lua脚本中的OnInit和OnOpen），这两个方法会获取到对应Lua脚本中相对应的OnInit和OnOpen函数来执行；





#### 实体（模型，特效等）

整个设计流程和UI基本一致：在Lua中调用C#中EntityManager中的ShowEntity，ShowEntity根据该实体是第几次调用，先触发OnInit再触发OnShow，这两个方法会获取到对应Lua脚本中相对应的OnInit和OnShow函数来执行



#### 场景

根据Unity场景的调用时的特性，去模拟成调用Lua版本的

包括：激活场景，叠加加载场景，切换场景，卸载场景

Manager里包含场景操作的对Lua的接口，接口方法中在调用资源后再触发Lua脚本的对应逻辑



#### 声音

- 音乐
  - 开始
  - 停止
  - 暂停
  - 继续
  - 音量
- 音效

声音管理器不需要LuaBehaviour，直接在Manager上操作AudioSource就可以了，也不需要后续调用Lua脚本模拟生命周期的特点





## 根与蚯蚓

### 根的移动

先获取到鼠标位置，再求出下一帧移动的方向向量，通过线渲染器不断生成线的下一个点来实现根的向下移动，移动的速度取决于设置的下一次生成新的点的时间间隔，当当前时间小于下一次生成新的点的时间间隔时，增加新的点，并根据求出的方向向量得到新的点的位置；动画的效果通过动态的设置线渲染器的动画曲线来实现，曲线上宽下窄，从而更像根的效果

### 随机关卡

LevelPool继承ScriptableObject类，并定义一个List用来存放一个LevelPool中可能出现的关卡模块，生成包含不同关卡模块的LevelPool数据；在LevelManager中定义一个List存放不同LevelPool，遍历每个LevelPool随机得到一个关卡模块并实例化

















# 自我介绍



我叫杨柳青，现在就读于上海大学的数字媒体技术专业的大三学生。接下来我介绍一下整个学习经历以及掌握的一些能力。您可以随时打断我。

从大二开始自学了一段时间的Unity，然后参加了全国数字媒体创意大赛，做了舟游京杭这个3D跑酷游戏，尝试去实现了一个系统功能较为完整的跑酷游戏；当时遇到的问题是希望能够更加偏向有教育意义的作品，因此我设计加入了一个根据不同关卡随机的答题复活系统，通过将题目转换为Json文件，再用Json.Net来反序列化读取题目，从而实现了游戏失败后根据不同的关卡随机出题来获得复活机会的功能，最后经过评选以后也拿到了一等奖；

然后在大三的上学期参加了网易MiniGame比赛活动，在规定的主题下我们在一个月时间做了一款2D的音游和跑酷相结合的游戏；我作为组长同时承担了绝大部分的策划，程序，和音乐的工作，以及和美术同学协调。因为这个游戏的玩法比较新颖，基本没有可以参考实现的模板，因此具体的实现方法都是自己一步步尝试，没有利用插件手动实现了一个根据音乐BPM速率判定在规定范围内是否有可以飞跃的游戏物体的功能；当时在开发完第一个场景以后发现由于大量不同的场景贴图以及UI内容，导致合批数量比较高，因此我通过将场景以及UI部分贴图打包成图集，从而降低合批的次数，优化了表现的性能。

之后加入了导师的团队，帮助导师开发一款类MMORPG项目，需要同时涉及到客户端，服务端以及数据库，在导师和学长的指导下，利用现有的框架，开发了道具，背包和商店三个系统功能的开发，本人负责的重心还是在、客户端和服务端的功能逻辑实现上，我来着重讲一下这一部分：这三个系统具有较强的关联性——背包和商店都需要依托道具系统；三个系统都是以一个类似MVC的结构去开发的，视图层与模型层是通过控制层联系起来的，两者之间并无直接的联系；对于一个相对大型的项目该结构可以很好的降低耦合，提高重用性，同时利于维护；具体来说模型层通常负责数据的处理和维护，在客户端需要作为一个可以被实例化的类型去使用，在服务端则是及时修改数据库内的数据；视图层主要是客户端UI部分，通过控制层得到的数据来实例化显示；控制层通常需要维护其对应类型的数据，实现具体的功能逻辑来操作这些数据，并影响视图层和模型层的数据和行为；由于需要网络通信，还多加一个服务层用于收发消息，项目框架中服务端和客户端之间的通信协议使用protobuf来生成，也便于高效的序列化和反序列化；

在这个设计模型下完成了大部分的系统功能实现，但在具体细节实现上遇到了困难：一、背包系统在开发的过程中发现背包内容如果通过protobuf定义数据结构的形式在两个端之间传递，开销是比较大的，尤其是背包数量大的时候，因此，通过将背包数据转化为二进制数组进行传递，规定四个字节表示一个道具，前两个字节为道具id，后两个字节代表道具数量，这样可以节省传递的开销；同时还需要把背包道具的模型层设计为结构体的形式而非类的形式，从而便于客户端解析二进制的背包信息时方便使用指针赋值（如果是类指针赋值时是浅拷贝），设计成值类型也便于后续如果有交换道具的需求可以便于实现。二、在商店系统的开发中，服务端返回的消息需要同时包含金币改变，道具改变的信息，如果通过一个消息发送又需要设计新的协议，复用性降低了，并且每条消息都要打包发送再解析同样产生消耗，因此通过后处理机制，将这些消息随其他主动发送的消息一起打包发送，这样能够减少发包的次数，同时也解决了服务器需要同时返回多个不同的响应的问题。三、是一个有意思的点，就是背包的整理功能，通过判断道具数量，小于一个格子的上限时直接赋值，如果大于时先减去格子上限的数值，并赋值后，在下一个格子循环判断是否小于格子上限，直至小于格子上限后直接赋值；

在这之后我了解到了实际项目开发中需要用lua进行热更新的工作，因此自学尝试实现了一个简单的xLua的热更新框架；我主要分为四个功能模块：Bundle构建，加载，热更新流程以及Lua与C#相互调用的系统框架；构建主要将需要打包的资源打包成ab包以及一个版本文件用来存放打包资源的信息，并构建到StreamingAssets中；加载是构建的逆过程，从版本文件中读取信息来加载文件；热更新流程主要是首先判断是否是初次安装，对于整包来说需要释放包内资源；接着将本地的版本文件和服务端版本文件做对比，并下载缺失的文件，最后就是加载bundle并启动游戏；系统框架则是通过Lua调用C#，再让C#按照Unity的生命周期去执行Lua，这样就可以将可能会频繁修改的逻辑放在Lua当中，便于更新脚本逻辑

最后在今年年后，我作为组长带领几个同学一起参加了GGJ48小时的游戏开发活动，完成了一个2D双人合作的休闲游戏；开发期间除了规化和协调推进整体进度以外，也解决了一些技术要点，比如随机的关卡生成，我通过ScriptableObject类将不同的关卡模块预制体组织在一起，并在每次开始游戏时随机的生成不同的关卡模块；以及通过线渲染器实现根移动的效果；































